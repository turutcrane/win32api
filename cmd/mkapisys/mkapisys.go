package main

import (
	"bytes"
	"flag"
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"strings"
	"text/scanner"
)

//go:generate goyacc.exe -o win32.y.go win32.y

var typeMap = map[string]string{
	"LPCWSTR": "*uint16",
	"LPPOINT": "*Point",
	"BOOL":    "bool",
}

func main() {
	out := flag.String("o", "", "output file")
	pkg := flag.String("pkg", "main", "package")
	var buf bytes.Buffer
	flag.Parse()

	buf.WriteString("// Code generated by mkapisys. DO NOT EDIT.\n")
	fmt.Fprintf(&buf, "package %s\n", *pkg)
	for _, arg := range flag.Args() {
		scanner := new(scanner.Scanner)
		// body, err := ioutil.ReadFile(arg)
		// if err != nil {
		// 	log.Fatal(err)
		// }
		// scanner.Init(string(body))
		f, err := os.Open(arg)
		if err != nil {
			log.Fatalln("T23", arg, err)
		}
		scanner.Init(f)
		for _, fdef := range Parse(scanner) {
			var ns, fv string
			var noerr bool
			for _, q := range fdef.funcQuals {
				switch q.qt {
				case QtNs:
					ns = q.val
				case QtFailRetVal:
					fv = q.val
				case QtNoerr:
					noerr = true
				default:
					log.Panicln("T41:", q)
				}
			}
			fmt.Fprintf(&buf, "//sys %s(", fname(*fdef))
			for i, p := range fdef.params {
				if i > 0 {
					buf.WriteString(", ")
				}
				fmt.Fprintf(&buf, "%s %s", p.pname.literal, convType(p.typespec))
			}
			fmt.Fprintf(&buf, ") (r %s", convType(fdef.typespec))
			if !noerr {
				buf.WriteString(", err error")
			}
			buf.WriteString(") ")
			if fv != "" {
				fmt.Fprintf(&buf, "[failretval==%s]", fv)
			}
			if ns != "" {
				fmt.Fprintf(&buf, " = %s.%s\n", ns, fdef.funcname.literal)
			} else {
				fmt.Fprintf(&buf, " = %s\n", fdef.funcname.literal)
			}
		}
	}
	if *out != "" {
		err := ioutil.WriteFile(*out, buf.Bytes(), 0644)
		if err != nil {
			log.Panicf("writing output: %s", err)
		}
	} else {
		os.Stdout.Write(buf.Bytes())
	}
}

func fname(f Funcdef) string {
	if strings.HasSuffix(f.funcname.literal, "W") {
		return f.funcname.literal[0 : len(f.funcname.literal)-1]
	}
	return f.funcname.literal
}

func convType(t Token) string {
	if t, ok := typeMap[t.literal]; ok {
		return t
	}
	return t.literal
}
